---
description: 
globs: 
alwaysApply: true
---
# Arquitectura Hexagonal PragmÃ¡tica - Reglas de Desarrollo

## ğŸ—ï¸ ESTRUCTURA DE CARPETAS OBLIGATORIA

```
src/
â”œâ”€â”€ domain/                    # Business core (sin dependencias externas)
â”‚   â”œâ”€â”€ entities/              # Entidades de negocio (User, Product, Order)
â”‚   â”œâ”€â”€ events/                # Eventos de dominio (UserCreated, OrderPlaced)
â”‚   â”œâ”€â”€ ports/                 # Interfaces/contratos (UserRepository, EmailService)
â”‚   â””â”€â”€ errors/                # Errores especÃ­ficos de dominio
â”œâ”€â”€ usecases/                  # LÃ³gica de aplicaciÃ³n (un caso de uso = una carpeta)
â”‚   â”œâ”€â”€ create_user/           # create_user.go, create_user_test.go
â”‚   â”œâ”€â”€ authenticate_user/     # authenticate_user.go, authenticate_user_test.go
â”‚   â”œâ”€â”€ place_order/           # place_order.go, place_order_test.go
â”‚   â””â”€â”€ [usecase_name]/        # Cada caso de uso en su propia carpeta
â”œâ”€â”€ infra/                     # Implementaciones externas
â”‚   â”œâ”€â”€ persistence/           # Implementaciones de persistencia
â”‚   â”‚   â”œâ”€â”€ dynamo/            # DynamoDB
â”‚   â”‚   â”œâ”€â”€ postgres/          # PostgreSQL
â”‚   â”‚   â””â”€â”€ memory/            # In-memory para testing
â”‚   â”œâ”€â”€ messaging/             # Publishers de eventos (RabbitMQ, Kafka)
â”‚   â”œâ”€â”€ cache/                 # Implementaciones de cachÃ© (Redis, in-memory)
â”‚   â””â”€â”€ external/              # APIs de terceros
â””â”€â”€ presentation/              # Capa de entrega (NO crear subcarpetas hasta necesitarlas)
    â”œâ”€â”€ handlers/              # HTTP handlers directamente
    â”œâ”€â”€ middlewares/           # Authentication, logging, CORS, etc.
    â”œâ”€â”€ dtos/                  # Request/response objects
    â””â”€â”€ routes/                # Definiciones de rutas
```

## ğŸ¯ PRINCIPIOS FUNDAMENTALES

### YAGNI (You Aren't Gonna Need It)
- NO crear carpetas hasta que realmente las necesites
- NO abstraer hasta tener mÃºltiples implementaciones
- Ejemplo: NO crear `/http/` en presentation hasta tener gRPC

### KISS (Keep It Simple, Stupid)
- Imports mÃ¡s cortos posibles
- Estructura autodocumentada
- Una responsabilidad por carpeta

### Dependency Inversion
- domain/ NUNCA importa de otras capas
- usecases/ solo importa de domain/
- adapters/ implementa ports/ de domain/
- presentation/ solo importa usecases/ y domain/

## ğŸ“ REGLAS DE ORGANIZACIÃ“N

### Domain Layer
- **entities/**: Structs de negocio puros, sin dependencias externas
- **events/**: Eventos que representan cambios importantes en el negocio
- **ports/**: Interfaces que definen contratos (repositories, services)
- **errors/**: Errores especÃ­ficos del dominio de negocio

### Use Cases Layer
- **Una carpeta por caso de uso**: createuser/, placeorder/, etc.
- **Naming**: Verbos en infinitivo, descriptivos
- **Contenido**: usecase.go, usecase_test.go, dtos especÃ­ficos si necesarios
- **NO agrupar por entidad**: Evitar user/, order/ - usar funcionalidad especÃ­fica

### Adapters Layer
- **persistence/**: Implementaciones de repositories
- **messaging/**: Publishers de eventos
- **cache/**: Implementaciones de cachÃ©
- **external/**: Clientes para APIs externas
- **Subcarpetas por tecnologÃ­a**: dynamo/, postgres/, redis/

### Presentation Layer
- **handlers/**: HTTP handlers directamente (sin /http/ hasta necesitarlo)
- **middlewares/**: Cross-cutting concerns
- **dtos/**: Request/response objects
- **routes/**: ConfiguraciÃ³n de rutas

## ğŸ”„ FLUJO DE DEPENDENCIAS

```
presentation/ â†’ usecases/ â†’ domain/
     â†“              â†“
adapters/ â†â†â†â†â† ports/ (domain/)
```

## ğŸ“ CONVENCIONES DE NAMING

### Archivos
- **Snake_case**: `create_user.go`, `place_order.go`
- **Tests**: `create_user_test.go`
- **Interfaces**: `UserRepository`, `EmailService` (PascalCase)

### Packages
- **Snake_case**: `create_user`, `place_order`
- **Descriptivos**: Que el import sea autodocumentado

### Imports
- **Relativos desde src/**: `domain/entities`, `usecases/createuser`
- **Cortos y claros**: Evitar anidaciÃ³n innecesaria

## âš¡ REGLAS DE REFACTORING

### CuÃ¡ndo crear subcarpetas
- **presentation/**: Solo cuando tengas mÃºltiples protocolos (HTTP + gRPC)
- **adapters/**: Solo cuando tengas mÃºltiples implementaciones
- **usecases/**: Solo cuando tengas lÃ³gica compartida entre casos de uso

### CÃ³mo evolucionar
1. **Empieza simple**: Archivos directos en carpetas principales
2. **Detecta duplicaciÃ³n**: Cuando veas patrones repetidos
3. **Refactoriza**: Mueve archivos a subcarpetas segÃºn necesidad real

## ğŸš« ANTI-PATRONES A EVITAR

- **NO** crear carpetas vacÃ­as "por si acaso"
- **NO** agrupar casos de uso por entidad si no hay lÃ³gica compartida
- **NO** crear abstracciones hasta tener mÃºltiples implementaciones
- **NO** importar desde capas superiores a inferiores
- **NO** poner lÃ³gica de negocio en presentation/ o adapters/

## âœ… CHECKLIST DE VALIDACIÃ“N

Antes de crear cÃ³digo, pregÃºntate:
- [ ] Â¿Esta carpeta tiene contenido real ahora?
- [ ] Â¿El import resultante es claro y corto?
- [ ] Â¿Estoy respetando el flujo de dependencias?
- [ ] Â¿Puedo explicar por quÃ© esta estructura en una frase?
- [ ] Â¿Un desarrollador nuevo encontrarÃ­a esto intuitivo?

## ğŸ¯ OBJETIVO FINAL

Crear una arquitectura que sea:
- **PragmÃ¡tica**: Basada en necesidades reales, no dogmas
- **Evolutiva**: Puede crecer sin reestructuraciÃ³n masiva
- **Autodocumentada**: Los imports y nombres explican el propÃ³sito
- **Developer-friendly**: FÃ¡cil navegaciÃ³n y comprensiÃ³n
- **Testeable**: Cada capa puede probarse independientemente